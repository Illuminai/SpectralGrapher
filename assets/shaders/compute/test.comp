#version 460

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

layout (binding = 1) uniform UniformBufferObject {
    vec3 position;
    vec3 rotation;
    float fov;
} ubo;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct RayIntersection {
    vec3 normal;
    int shape;
};

mat3 getRotationMatrix(vec3 angles) {
    vec2 x = vec2(cos(angles.x), sin(angles.x));
    vec2 y = vec2(cos(angles.y), sin(angles.y));
    vec2 z = vec2(cos(angles.z), sin(angles.z));

    mat3 rot;
    rot[0] = vec3(y.x * z.x, -y.x * z.y, y.y);
    rot[1] = vec3(z.x * x.y * y.y + x.x * z.y,
                  x.x * z.x - x.y * y.y * z.y,
                  -y.x * x.y);
    rot[2] = vec3(-x.x * z.x * y.y + x.y * z.y,
                  z.x * x.y + x.x * y.y * z.y,
                  x.x * y.x);

    return rot;
}

Ray getRay(float u, float v, vec3 camPos, vec3 camRot, float camFOV) {
    mat3 rotMat = getRotationMatrix(camRot);
    vec3 viewDirection = rotMat * vec3(camFOV, 0, 0);
    vec3 cameraRight = rotMat * vec3(0, 1, 0);
    vec3 cameraUp = rotMat * vec3(0, 0, -1);
    return Ray(camPos, normalize(viewDirection + cameraRight * u + cameraUp * v));
}

float getDistance(vec3 point) {
    return length(point - vec3(3.0f, 3.0f, 3.0f)) - 4.0f;
}

vec3 estimateNormal(vec3 point) {
    vec3 normal = normalize(vec3(
            getDistance(point + vec3(10e-6, 0, 0)) - getDistance(point - vec3(10e-6, 0, 0)),
            getDistance(point + vec3(0, 10e-6, 0)) - getDistance(point - vec3(0, 10e-6, 0)),
            getDistance(point + vec3(0, 0, 10e-6)) - getDistance(point - vec3(0, 0, 10e-6))
    ));
    return normal;
}

vec3 getPointOnRay(Ray ray, float time) {
    return ray.origin + ray.direction * time;
}

RayIntersection traceRay(Ray ray) {
    float time = 0;
    int maxDist = 100;

    while (time < maxDist) {
        vec3 point = getPointOnRay(ray, time);
        float distance = getDistance(point);

        if (distance <= 10e-6) {
            vec3 normal = estimateNormal(point);
            return RayIntersection(normal, 1);
        }
        time += getDistance(point);
    }
    return RayIntersection(vec3(0.0f, 0.0f, 0.0f), -1);
}

vec3 getNormalColor(RayIntersection inter) {
    return vec3((inter.normal.x + 1.0f) * 0.5f, (inter.normal.y + 1.0f) * 0.5f,
                (inter.normal.z + 1.0f) * 0.5f);
}

void main() {
    vec2 pixCo = gl_GlobalInvocationID.xy;
    ivec2 imgSize = imageSize(resultImage);

    float u = 2.0f * ((pixCo.x + 0.5f) / imgSize.x) - 1.0f;
    float v = 2.0f * ((pixCo.y + 0.5f) / imgSize.y);

    Ray ray = getRay(u, v, ubo.position.xyz, ubo.rotation.xyz, ubo.fov);
    RayIntersection intersection = traceRay(ray);

    vec3 color = vec3(0, 0, 0);
    if (intersection.shape != -1) {
        float factor = max(0.0f, dot(intersection.normal, -ray.direction));
        color = factor * getNormalColor(intersection);
    }

    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 0.0));

    if (pixCo.y == 27 || (pixCo.x == imgSize.x - 150 && pixCo.y < 27) || (pixCo.x == 40 && pixCo.y < 27) ) {
        imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(1.0, 1.0, 0.0, 0.0));
    }
}



